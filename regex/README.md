# regex 正则表达式

## 基本匹配

正则表达式其实就是在执行搜索时的格式，它由一些字母和数字组合而成。  
例如：一个正则表达式`the`，它表示一个规则：由字母`t`开始，接着是`h`，再接着是`e`。
<pre>
"the" => The fat cat sat on <kbd>the</kbd> mat.
</pre>
正则表达式`123`匹配字符串`123`。  
它逐个字符的与输入的正则表达式做比较。  
正则表达式是大小写敏感的，所以`The`不会匹配`the`。
<pre>
"The" => <kbd>The</kbd> fat cat sat on the mat.
</pre>

## 元字符

正则表达式主要依赖于元字符。  
元字符不代表他们本身的字面意思，他们都有特殊的含义。  
一些元字符写在方括号中的时候有一些特殊的意思。  
以下是一些元字符的介绍：
| 元字符 | 描述                                                        |
| ------ | ----------------------------------------------------------- |
| .      | 句号匹配任意单个字符除了换行符                              |
| []     | 字符种类。匹配方括号内的任意字符                            |
| [^]    | 否定的字符种类。匹配除了方括号里的任意字符                  |
| *      | 匹配>=0个重复的在*号之前的字符                              |
| +      | 匹配>=1个重复的+号前的字符                                  |
| ?      | 标记?之前的字符为可选                                       |
| {n,m}  | 匹配num个大括号之前的字符或字符集(n<=num<=m)                |
| (xyz)  | 字符集，匹配与xyz完全相等的字符串                           |
| \|     | 或运算符，匹配符号前或后的字符                              |
| \      | 转义字符，用于匹配一些保留的字符<code>[](){}.*+?^$\|</code> |
| ^      | 从开始行开始匹配                                            |
| $      | 从末端开始匹配                                              |

### . 点运算符

`.`是元字符中最简单的例子。  
`.`匹配任意单个字符，但不匹配换行符。  
例如：表达式`.ar`匹配一个任意字符后面跟着是`a`和`r`的字符串。
<pre>
".ar" => The <kbd>car</kbd> <kbd>par</kbd>ked in the <kbd>gar</kbd>age.
</pre>

### [] 字符集

字符集也叫做字符类。  
方括号用来指定一个字符集。  
在方括号中使用连字符来指定字符集的范围。  
在方括号中的字符集不关心顺序。  
例如：表达式`[Tt]he`匹配`the`和`The`。
<pre>
"[Tt]he" => <kbd>The</kbd> car parked in <kbd>the</kbd> garage.
</pre>
方括号的句号就表示句号。  
表达式`ar[.]`匹配`ar.`字符串
<pre>
"ar[.]" => A garage is a good place to park a c<kbd>ar.</kbd>
</pre>

### [^] 否定字符集

一般来说`^`表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。  
例如：表达式`[^c]ar`匹配一个后面跟着`ar`的除了`c`的任意字符。
<pre>
"[^c]ar" => The car <kbd>par</kbd>ked in the <kbd>gar</kbd>age.
</pre>

### *+? 重复次数

后面跟着元字符`*+?`的，用来指定匹配子模式的次数。  
这些元字符在不同的情况下有着不同的意思。

### *大于等于0次

`*`号匹配 在`*`之前的字符出现`大于等于0次`。  
例如：表达式`a*`匹配0或更多个以a开头的字符。表达式`[a-z]*`匹配一个行中所有以小写字母开头的字符串。
<pre>
"[a-z]*" => T<kbd>he</kbd> <kbd>car</kbd> <kbd>parked</kbd> <kbd>in</kbd> <kbd>the</kbd> <kbd>garage</kbd> #21.
</pre>
`*`字符和`.`字符搭配可以匹配所有的字符`.*`。  
`*`和表示匹配空格的符号`\s`连起来用，例如：表达式`\s*cat\s*`匹配0或更多个空格开头和0或更多个空格结尾的cat字符串。  
<pre>
"\s*cat\s*" => The fat<kbd> cat </kbd>sat on the con<kbd>cat</kbd>enation.
</pre>

### + 大于等于1次

`+`号匹配`+`号之前的字符出现`大于等于1次`。  
例如：表达式`c.+t`匹配以首字母`c`开头以`t`结尾，中间跟着至少一个字符的字符串。
<pre>
"c.+t" => The fat <kbd>cat sat on the mat</kbd>.
</pre>

### ? 0或1次

在正则表达式中元字符`?`标记在符号前面的字符为可选，即出现`0或1次`。  
例如：表达式`[T]?he`匹配字符串`he`和`The`。
<pre>
"[T]he" => <kbd>The</kbd> car is parked in the garage.
</pre>
<pre>
"[T]?he" => <kbd>The</kbd> car is parked in t<kbd>he</kbd> garage.
</pre>

### {} 限定重复次数

在正则表达式中`{}`是一个量词，常用来限定一个或一组字符可以重复出现的次数。  
例如：表达式`[0-9]{2,3}`匹配最少2位最多3位0~9的数字。
<pre>
"[0-9]{2,3}" => The number was 9.<kbd>999</kbd>7 but we rounded it off to <kbd>10</kbd>.0.
</pre>
我们可以省略第二个参数。  
例如：`[0-9]{2,}`匹配至少两位0~9的数字。
<pre>
"[0-9]{2,}" => The number was 9.<kbd>9997</kbd> but we rounded it off to <kbd>10</kbd>.0.
</pre>
如果逗号也省略掉则表示重复固定的次数。  
例如：`[0-9]{3}`匹配3位数字
<pre>
"[0-9]{3}" => The number was 9.<kbd>999</kbd>7 but we rounded it off to 10.0.
</pre>

### () 特征标群

特征标群是一组写在`(...)`中的子模式。  
`(...)`中包含的内容将会被看成一个整体，和数学中小括号`()`的作用相同。  
例如：表达式`(ab)*`匹配连续出现0或更多个`ab`。如果没有使用`(...)`，那么表达式`ab*`将匹配连续出现0或更多个`b`。  
再比如之前说的`{}`是用来表示前面一个字符出现指定次数。但如果在`{}`前加上特征标群`(...)`则表示整个标群内的字符重复N次。  
我们还可以在`()`中用或字符`|`表示或。  
例如：`(c|g|p)ar`匹配`car`或`gar`或`par`
<pre>
"(c|g|p)ar" => The <kbd>car</kbd> is <kbd>par</kbd>ked in the <kbd>gar</kbd>age.
</pre>

### | 或运算符

或运算符就表示或，用作判断条件。  
例如：`(T|t)he|car`匹配`(T|t)he`或`car`。
<pre>
"(T|t)he|car" => <kbd>The</kbd> <kbd>car</kbd> is parked in <kbd>the</kbd> garage.
</pre>

### \ 转码特殊字符

反斜线`\`在表达式中用于转码紧跟其后的字符。用于指定`{ } [ ] / \ + * . $ ^ | ?`这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线`\`。  
例如`.`是用来匹配除换行符外的所有字符的。如果想要匹配句子中的`.`则要写成`\.`以下这个例子`\.?`是选择性匹配`.`
<pre>
"(f|c|m)at\.?" => The <kbd>fat</kbd> <kbd>cat</kbd> sat on the <kbd>mat.</kbd>
</pre>

### ^$ 锚点

在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。`^`指定开头，`$`指定结尾。

### ^ 匹配开头

`^`用来检查匹配的字符串是否在所匹配字符串的开头。  
例如：在`abc`中使用表达式`^a`会得到结果`a`。但如果使用`^b`将匹配不到任何结果。因为在字符串`abc`中并不是以`b`开头。  
例如：`^(T|t)he`匹配以`The`或`the`开头的字符串。
<pre>
"(T|t)he" => <kbd>The</kbd> car is parked in <kbd>the</kbd> garage.
</pre>
<pre>
"^(T|t)he" => <kbd>The</kbd> car is parked in the garage.
</pre>

### $ 匹配结尾

同理于`^`号，`$`号用来匹配字符是否是最后一个。  
例如：`(at\.)$`匹配以`at.`结尾的字符串。
<pre>
"(at\.)" => The fat c<kbd>at.</kbd> s<kbd>at.</kbd> on the m<kbd>at.</kbd>
</pre>
<pre>
"(at\.)$" => The fat cat. sat. on the m<kbd>at.</kbd>
</pre>

## 简写字符集

正则表达式提供一些常用的字符集简写。如下:
| 简写 | 描述                                         |
| ---- | -------------------------------------------- |
| .    | 除换行符外的所有字符                         |
| \w   | 匹配所有字母数字，等同于`[a-zA-Z0-9_]`       |
| \W   | 匹配所有非字母数字，即符号，等同于：`[^\w]`  |
| \d   | 匹配数字：`[0-9]`                            |
| \D   | 匹配非数字：`[^\d]`                          |
| \s   | 匹配所有空格字符，等同于：`[\t\n\f\r\p{Z}]`  |
| \S   | 匹配所有非空格字符：`[^\s]`                  |
| \f   | 匹配一个换页符                               |
| \n   | 匹配一个换行符                               |
| \r   | 匹配一个回车符                               |
| \t   | 匹配一个制表符                               |
| \v   | 匹配一个垂直制表符                           |
| \p   | 匹配CR/LF(等同于`\r\n`)，用来匹配DOS行终止符 |

## 零宽度断言(前后预查)

先行断言和后发断言都属于**非捕获簇**(不捕获文本，也不针对组合计进行计数)。  
先行断言用于判断所匹配的格式是否在另一个确定的格式之前，匹配结果不包含该确定格式(仅作为约束)。  
例如：我们想要获得所有跟在`$`符号后的数字，我们可以使用正后发断言`(?<=\$)[0-9\.]*`。  
这个表达式匹配`$`开头，之后跟着`0,1,2,3,4,5,6,7,8,9,.`这些字符可以出现大于等于0次。  
零宽度断言如下：
| 符号 | 描述            |
| ---- | --------------- |
| ?=   | 正先行断言-存在 |
| ?!   | 负先行断言-排除 |
| ?<=  | 正后发断言-存在 |
| ?<!  | 负后发断言-排除 |

### ?= 正先行断言

`?=...`正先行断言，表示第一部分表达式之后必须跟着`?=...`定义的表达式。  
返回结果只包含满足匹配条件的第一部分表达式。  
定义一个正先行断言要使用`()`。在括号内部使用一个问号和等号：`(?=...)`。  
正先行断言的内容写在括号中的等号后面。  
例如：表达式`(T|t)he(?=\sfat)`匹配`The`和`the`，在括号中我们又定义了正先行断言`(?=\sfat)`，即`The`和`the`后面紧跟着`(空格)fat`。
<pre>
"(T|t)he(?=\sfat)" => <kbd>The</kbd> fat cat sat on the mat.
</pre>

### ?! 负先行断言

负先行断言记作`?!`用于筛选所有匹配结果，筛选条件为其后不跟随着断言中定义的格式。  
`正先行断言`定义和`负先行断言`一样，区别就是`=`替换成`!`也就是`(?!...)`。  
表达式`(T|t)he(?!\sfat)`匹配`The`和`the`，且其后不跟着`(空格)fat`。
<pre>
"(T|t)he(?!\sfat)" => The fat cat sat on <kbd>the</kbd> mat.
</pre>

### ?<= 正后发断言

正后发断言记作`(?<=...)`用于筛选所有匹配结果，筛选条件为其前跟随着断言中定义的格式。  
例如：表达式`(?<=(T|t)he\s)(fat|mat)`匹配`fat`和`mat`，且其前跟着`The`或`the`。
<pre>
"(?<=(T|t)he\s)(fat|mat)" => The <kbd>fat</kbd> cat sat on the <kbd>mat</kbd>.
</pre>

### ?<! 负后发断言

负后发断言记作`(?<!...)`用于筛选所有匹配结果，筛选条件为其前不跟随着断言中定义的格式。
例如：表达式`(?<!(T|t)he\s)(cat)`匹配`cat`，且其前不跟着`The`或`the`。
<pre>
"(?&lt;!(T|t)he\s)(cat)" => The cat sat on <kbd>cat</kbd>.
</pre>

## 标志

标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。  
这些标志可以任意的组合使用，它也是整个正则表达式的一部分。
| 标志 | 描述                                               |
| ---- | -------------------------------------------------- |
| i    | 忽略大小写。                                       |
| g    | 全局搜索。                                         |
| m    | 多行修饰符：锚点元字符`^``$`工作范围在每行的起始。 |

### i 忽略大小写

修饰语`i`用于忽略大小写。  
例如：表达式`/The/gi`表示在全局搜索`The`，在后面的`i`将其条件修改为忽略大小写，则变成搜索`the`和`The`，`g`表示全局搜索。
<pre>
"The" => <kbd>The</kbd> fat cat sat on the mat.
</pre>
<pre>
"/The/gi" => <kbd>The</kbd> fat cat sat on <kbd>the</kbd> mat.
</pre>

### g 全局搜索

修饰符`g`常用于执行一个全局搜索匹配，即(不仅仅返回第一个匹配的，而是返回全部)。  
例如：表达式`/.(at)/g`表示搜索任意字符(除了换行)+`at`，并返回全部结果。
<pre>
"/.(at)/" => The <kbd>fat</kbd> cat sat on the mat.
</pre>
<pre>
"/.(at)/g" => The <kbd>fat</kbd> <kbd>cat</kbd> <kbd>sat</kbd> on the <kbd>mat</kbd>.
</pre>

### m 多行修饰符

多行修饰符`m`常用于执行一个多行匹配。  
像之前介绍的`(^,$)`用于检查格式是否是在待检测字符串的开头或结尾。但我们如果想要它在每行的开头和结尾生效，我们需要用到多行修饰符`m`。  
例如：表达式`/at(.)?$/gm`表示小写字符`a`后跟小写字符`t`，末尾可选除换行符外任意字符。根据`m`修饰符，现在表达式匹配每行的结尾。
<pre>
"/.at(.)?$/" => The fat
                cat sat
                on the <kbd>mat.</kbd>
</pre>
<pre>
"/.at(.)?$/gm" => The <kbd>fat</kbd>
                  cat <kbd>sat</kbd>
                  on the <kbd>mat.</kbd>
</pre>

### ? 贪婪匹配与惰性匹配

正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用`?`将贪婪匹配模式转化为惰性匹配模式。
<pre>
"/(.*at)/" => <kbd>The fat cat sat on the mat</kbd>.
</pre>
<pre>
"/(.*?at)/" => <kbd>The fat</kbd> cat sat on the mat.
</pre>

## 常用

### 数字

- 数字：`^[0-9]*$`
- n位的数字：`^\d{n}$`
- 至少n位的数字：`^\d{n,}$`
- m-n位的数字：`^\d{m,n}$`
- 零和非零开头的数字：`^(0|[1-9][0-9]*)$`
- 非零开头的最多带两位小数的数字：`^([1-9][0-9]*)+(\.[0-9]{1,2})?$`
- 带1-2位小数的正数或负数：`^(\-)?\d+(\.\d{1,2})$`
- 正数、负数、和小数：`^(\-|\+)?\d+(\.\d+)?$`
- 有2位小数的正实数：`^[0-9]+(\.[0-9]{2})?$`
- 有1~3位小数的正实数：`^[0-9]+(\.[0-9]{1,3})?$`
- 非零的正整数：`^[1-9]\d*$`或`^([1-9][0-9]*){1,3}$`或`^\+?[1-9][0-9]*$`
- 非零的负整数：`^\-[1-9][]0-9"*$`或`^-[1-9]\d*$`
- 非负整数：`^\d+$`或`^[1-9]\d*|0$`
- 非正整数：`^-[1-9]\d*|0$`或`^((-\d+)|(0+))$`
- 非负浮点数：`^\d+(\.\d+)?$`或`^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$`
- 非正浮点数：`^((-\d+(\.\d+)?)|(0+(\.0+)?))$`或`^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$`
- 正浮点数：`^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$`或`^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9]- [0-9]*))$`
- 负浮点数：`^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$`或`^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*- [1-9][0-9]*)))$`
- 浮点数：`^(-?\d+)(\.\d+)?$`或`^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$`

### 字符

- 汉字：`^[\u4e00-\u9fa5]{0,}$`
- 双字节字符：`[^\x00-\xff]`(包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))
- 英文和数字：`^[A-Za-z0-9]+$`或`^[A-Za-z0-9]{4,40}$`
- 长度为3-20的所有字符：`^.{3,20}$`
- 由26个英文字母组成的字符串：`^[A-Za-z]+$`
- 由26个大写英文字母组成的字符串：`^[A-Z]+$`
- 由26个小写英文字母组成的字符串：`^[a-z]+$`
- 由数字和26个英文字母组成的字符串：`^[A-Za-z0-9]+$`
- 由数字、26个英文字母或者下划线组成的字符串：`^\w+$`或`^\w{3,20}$`
- 中文、英文、数字包括下划线：`^[\u4E00-\u9FA5A-Za-z0-9_]+$`
- 中文、英文、数字但不包括下划线等符号：`^[\u4E00-\u9FA5A-Za-z0-9]+$`或`^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$`
- 可以输入含有`^%&',;=?$\"`等字符：`[^%&',;=?$\x22]+`
- 禁止输入含有`~`的字符：`[^~\x22]+`

### 特殊

- 邮箱地址：`^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$`
- 域名：`[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(\.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+\.?`
- URL：`[a-zA-z]+://[^\s]*`或`^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$`
- 手机号码：`^(13[0-9]|14[5|7]|15[0|1|2|3|4|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$`
- 电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：`^(\(\d{3,4}-)|\d{3.4}-)- ?\d{7,8}$`
- 国内电话号码("XXXX-XXXXXXX"和"XXX-XXXXXXXX")：`\d{3}-\d{8}|\d{4}-\d{7}`
- 电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1-4位分机号）：`((\d{11})|^((\d{7,8})|(\d{4}|\d{3})-(\d{7,8})|- (\d{4}|\d{3})-(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1})|(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1}))$)`
- 身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：`(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)`
- 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：`^[a-zA-Z][a-zA-Z0-9_]{4,15}$`
- 密码(以字母开头，长度在6-18之间，只能包含字母、数字和下划线)：`^[a-zA-Z]\w{5,17}$`
- 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：`^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]{8,- 10}$`
- 强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)：`^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$`
- 日期格式：`^\d{4}-\d{1,2}-\d{1,2}`
- 一年的12个月(01～09和1～12)：`^(0?[1-9]|1[0-2])$`
- 一个月的31天(01～09和1～31)：`^((0?[1-9])|((1|2)[0-9])|30|31)$`
- 钱的输入格式：
  - 有四种钱的表示形式我们可以接受：`10000.00`和`10,000.00`，和没有小数的`10000`和`10,000`：`^[1-9][0-9]*$`
  - 这表示任意一个不以0开头的数字，但是这也意味着一个字符`0`不通过，所以我们采用下面的形式：`^(0|[1-9][0-9]*)$`
  - 一个0或者一个不以0开头的数字，我们还可以允许开头有一个负号：`^(0|-?[1-9][0-9]*)$`
  - 这表示一个0或者一个可能为负的开头不为0的数字，让用户以0开头好了。把负号的也去掉，因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：`^[0-9]+(.[0-9]+)?$`
  - 必须说明的是，小数点后面至少应该有1位数，所以`10.`是不通过的,但是`10`和`10.2`是通过的：`^[0-9]+(.[0-9]{2})?$`
  - 这样我们规定小数点后面必须有两位，如果你认为太苛刻了，可以这样：`^[0-9]+(.[0-9]{1,2})?$`
  - 这样就允许用户只写一位小数。下面我们该考虑数字中的逗号了，我们可以这样：`^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$`
  - 1到3个数字，后面跟着任意个逗号+3个数字，逗号成为可选，而不是必须：`^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$`
- xml文件：`^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$`
- 空白行的正则表达式：`\n\s*\r`(可以用来删除空白行)
- HTML标记的正则表达式：`<(\S*?)[^>]*>.*?|<.*? />`(首尾空白字符的正则表达式：`^\s*|\s*$`或`(^\s*)|(\s*$)`(可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)
- 腾讯QQ号：`[1-9][0-9]{4,}`(腾讯QQ号从10000开始)
- 中国邮政编码：`[1-9]\d{5}(?!\d)`(中国邮政编码为6位数字)
- IPv4地址：`((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})(\.((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})){3}`
